<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8">
    <meta name="renderer" content="webkit">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
    <meta name="description" content="童话说，一个关于Web前端的个人技术博客，不定期发布Web前端及其相关技术的博文">
    <meta name="keywords" content="tonghuashuo,github,前端,html,css,javascript,android">
	<title>Stack Calculator - Blog|TongHuaShuo</title>
	<link rel="shortcut icon" href="../../img/favicon.ico" />
	<link rel="stylesheet" href="../../css/index.css" />
	<link rel="stylesheet" href="../../css/blog.css" />
</head>
<body>

	<div id="mf_content">
		<article id="stackcalculator">
			<h1>Stack Calculator</h1>
			<div class="time"><time datetime="2015-02-10">Feb 10th 2015<time></div>
			<div class="titleBanner"></div>
			<p id="buttons">
				<a href="../../case/stackcalculator/stack-calculator.html" target="_blank" class="view_demo">Demo</a>
				<a href="https://github.com/tonghuashuo/calculator" target="_blank" class="view_source">Source Code</a>
			</p>

			<h2>Intro</h2>
			<p>Implementing a formula calculator using stack is a classic case in Data Structure. Has been metioned in many text books about Data Structure. Here is a demo developed by JavaScript.</p>

			<h2>Principle</h2>
			<p>To do this. We need 2 stacks. One stores operators, the other one stores number. During the reading process, we compare the operators according to their priorities. Then we decide whether to calculate or wait for the next operator. So the key of this algorithm is to set up a table that records the priority relationship between any two operators. We can do it using an array.</p>
			<pre><code>function compare(op1, op2) {
    var table = new Array(7);
	
    //  1: '&gt;'
    // -1: '&lt;'
    //  0: '='
    //  9: no relationship
    table[0] = [ 1,  1, -1, -1, -1,  1,  1];
    table[1] = [ 1,  1, -1, -1, -1,  1,  1];
    table[2] = [ 1,  1,  1,  1, -1,  1,  1];
    table[3] = [ 1,  1,  1,  1, -1,  1,  1];
    table[4] = [-1, -1, -1, -1, -1,  0,  9];
    table[5] = [ 1,  1,  1,  1,  9,  1,  1];
    table[6] = [-1, -1, -1, -1, -1,  9,  0];

    // locate the 2 operators
    var ops = ['+', '-', '*', '/', '(', ')', '#'];
    var row = ops.indexOf(op1);
    var col = ops.indexOf(op2);
	
    return table[row][col];
}           </code></pre>
			<p>The Variable <span class="code">table</span> is the priority relationship table we talked above. Order is defined in variable <span class="code">ops</span>. Notice we have an extra operator <span class="code">#</span>. It marks the begining and end of the whole process. It only appears in two place: one at the botton of operator stack<span class="code">op</span>, one at the right of the formula. <span class="code">table[i]</span> records the priority of the No.i operator in <span class="code">ops</span> when it meets the next operator.</p>
			<p>Now we have the table. We can start interpretating the formula. First we create the two stacks: <span class="code">num</span> and <span class="code">op</span> (In Javascript, a stack is also an array). Then we push a <span class="code">#</span> into <span class="code">op</span> for initialization.</p>
			<pre><code>function calculate(formula) {
    var num = [];                                // stack of Digits
    var op  = [];                                // stack of Operators
    op.push('#');                                // begin symbol
    displayStatus(op, num, formula);             // Inital status

    var cache = null;                            // stores last character read in
    var c     = formula.charAt(0);               // get first character.
    while(c!='#' || op[op.length-1] != '#') {    // # means end of calculation
        if( isNumber(c) ) {

            // handel numbers &gt; 9 (2+ digits)
            if(cache!=null && isNumber(cache)) {
                var tmp = Number(cache)*10 + Number(c);
                num[num.length-1] = tmp;
            } else {
                num.push(c);
            }
            cache = c;                                      // cache last character
            formula = formula.substring(1, formula.length);
            c = formula.charAt(0);                          // get next character
        } else {    // Not number, operator
            switch(compare(op[op.length-1], c)) {
                case -1:     // the latter has higher priority, wait
                    op.push(c);
                    cache = c;
                    formula = formula.substring(1, formula.length);
                    c = formula.charAt(0);
                    break;
                case 0:     // same priority, ')' or '#'
                    op.pop();
                    cache = c;
                    formula = formula.substring(1, formula.length);
                    c = formula.charAt(0);
                    break;
                case 1:     // the former has higher priority, calculate
                    var o = op.pop();
                    var b = num.pop();
                    var a = num.pop();
                    var r = cal(o, a, b);
                    num.push(r);
                    cache = c;
                    break;
                default:
                    break;
            } // end of switch
        } // end of else
        displayStatus(op, num, formula);
   } // end of while
   return num[num.length-1];
}			</code></pre>
			<p>The <span class="code">displayStatus(op, num, formula)</span> function simply displays each step of the interpretation so we can see what's going on. The <span class="code">isNumber(c)</span> function returns a boolean value telling whether character <span class="code">c</span> is a number or an operator. The <span class="code">compare(op1, op2)</span> function was given in the first code sample. It compares two operator to see which one has higher priority.The <span class="code">cal(o, a, b)</span> function does a simple calculation of two numbers. These are too simple so there will be no necessity to paste the codes.</p>
			<p>The programme reads one character from the left of the formula each time. Identify it's a number or operator and then push into the related stack. Compare the adjacent two operators at the top of the stack <span class="code">op</span> and decide whether to calculate or wait for higher priority calculation. Continue this until finally there's only <span class="code">#</span> in <span class="code">op</span>. And that means the end.</p>
			<p>The programme reads one character from the formula each time. This brings a problem: what if the munber is > 9 (which means more than one character, eg.23, 768, 1024). To solve this problem. I have this variable <span class="code">cache</span> after initializing the stacks. This variable will cache the last character read from the formula. Then we compare it with the current input. if both were number, then join them as one.</p>
			<p>For the same reason we have this problem about negative numbers (operator minus followed by number). we have to check whether it's a minus or it's part of a number. Also the negative number can be at the begining of the formula (without quotes) or in the middle of the formula (surrounded by quotes). So does the decimal point.</p>
			<p>OK. Now we can read the numbers and operators correctly. How do we know whether to calculate or wait for further input? Here's the algorithm: read in one character. if it's number, push into <span class="code">num</span>. if it's operator, then refer to the priority relationship table. There're 3 kind of relationship between operators (here we use <span class="code">op1</span> to desrcibe the top element of <span class="code">op</span>, <span class="code">op2</span> to desrcibe the input)</p>

			<h3>1. <span class="code">op1</span> has lower priority than <span class="code">op2</span></h3>
			<p>This situation dedicates that the next operator might still have higher priority. so we just push it into <span class="code">op</span> and wait for further input.</p>
			
			<h3>2. <span class="code">op1</span> has higher priority than <span class="code">op2</span></h3>
			<p>This means there won't be any higher priority operators by now. We shall do the calculation. So we hold the input (not push into stack). pop two numbers from the top of <span class="code">num</span> and one operator from the top of <span class="code">op</span>. Calculate "num1 op num2" and push the result back to <span class="code">num</span>.</p>

			<h3>3. <span class="code">op1</span> and <span class="code">op2</span> share the same priority.</h3>
			<p>There're two possibility in this case: Either the top of <span class="code">op</span> is <span class="code">(</span> and the input is <span class="code">)</span>. it's a match so we clear them out. Or the top of <span class="code">op</span> is <span class="code">#</span> and the input is also <span class="code">#</span>. This shows the end of the formula. We are done for the circulation. There should be only one number in <span class="code">num</span> and that is the answer.</p>

			<h2>Summary</h2>
			<p>Stack is one of the fundamentals of data structure. Implementing a stack calculator can't be more classic. But most cases in text books only went through the four arithmetic operations of non-negative numbers &lt; 10. It's necessary that we write the cod ourselves so we can find there's more then that to be complete.</p>
		</article>

	</div>

	<script src="../../js/index.js"></script>
</body>
</html>